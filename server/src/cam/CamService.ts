import sharp from 'sharp';
import * as makerjs from 'makerjs';
import { RasterOptions, VectorOptions, LaserTool } from './Tools.js';

export class CamService {

    async generateVector(fileContent: string, options: VectorOptions): Promise<string> {
        const { tool, format, feedrate } = options;

        const rootModel: makerjs.IModel = { models: {} };

        // 1. Parse Input
        if (format === 'svg') {
            // Manual SVG Parsing
            const xml2js = await import('xml2js');
            const parser = new xml2js.Parser();
            try {
                const result = await parser.parseStringPromise(fileContent);

                const traverse = (obj: any) => {
                    if (obj.path) {
                        obj.path.forEach((p: any, index: number) => {
                            if (p.$ && p.$.d) {
                                const pathModel = makerjs.importer.fromSVGPathData(p.$.d);
                                if (rootModel.models) {
                                    rootModel.models[`path_${index}_${Math.random()}`] = pathModel;
                                }
                            }
                        });
                    }
                    if (obj.g) {
                        obj.g.forEach((g: any) => traverse(g));
                    }
                };

                if (result.svg) {
                    traverse(result.svg);
                }
            } catch (e) {
                throw new Error('Failed to parse SVG XML');
            }
        } else if (format === 'dxf') {
            throw new Error('DXF not supported in this version');
        }

        // 3. Generate G-code via Custom Walker
        const commands: string[] = [];
        const f = feedrate;

        // Header
        commands.push('; Generated by LzrCnc (Vector)');
        commands.push('G90');
        commands.push('G21');
        commands.push(`F${f}`);
        commands.push(tool.type === 'laser' ? 'M3 S0' : 'M3');

        // Walker setup
        const walk = (model: makerjs.IModel, offset = { x: 0, y: 0 }) => {
            if (model.paths) {
                for (const id in model.paths) {
                    const path = model.paths[id];
                    if (!path) continue;

                    const origin = makerjs.point.add(path.origin, [offset.x, offset.y]);
                    const xStart = origin[0].toFixed(3);
                    const yStart = origin[1].toFixed(3);

                    // Move to start
                    commands.push(`G0 X${xStart} Y${yStart}`);

                    // Laser On
                    if (tool.type === 'laser') {
                        commands.push(`M3 S${tool.powerMax || 1000}`);
                    }

                    if (path.type === 'line') {
                        const line = path as makerjs.paths.Line;
                        const end = makerjs.point.add(line.end, [offset.x, offset.y]);
                        commands.push(`G1 X${end[0].toFixed(3)} Y${end[1].toFixed(3)}`);
                    } else if (path.type === 'circle') {
                        const circle = path as makerjs.paths.Circle;
                        const r = circle.radius;
                        const center = origin;
                        const startX = center[0] + r;
                        const startY = center[1];

                        // Correct Move to start
                        commands.pop(); // Remove prev G0
                        if (tool.type === 'laser') commands.pop(); // Remove prev M3

                        commands.push(`G0 X${startX.toFixed(3)} Y${startY.toFixed(3)}`);
                        if (tool.type === 'laser') commands.push(`M3 S${tool.powerMax || 1000}`);

                        commands.push(`G2 I${(-r).toFixed(3)} J0`);

                    } else if (path.type === 'arc') {
                        const arc = path as makerjs.paths.Arc;
                        const p1 = makerjs.point.fromPolar(arc.startAngle, arc.radius);
                        const p2 = makerjs.point.fromPolar(arc.endAngle, arc.radius);
                        const center = origin;

                        const absStart = makerjs.point.add(center, p1);
                        const absEnd = makerjs.point.add(center, p2);

                        commands.pop();
                        if (tool.type === 'laser') commands.pop();

                        commands.push(`G0 X${absStart[0].toFixed(3)} Y${absStart[1].toFixed(3)}`);
                        if (tool.type === 'laser') commands.push(`M3 S${tool.powerMax || 1000}`);

                        const I = (center[0] - absStart[0]).toFixed(3);
                        const J = (center[1] - absStart[1]).toFixed(3);

                        commands.push(`G3 X${absEnd[0].toFixed(3)} Y${absEnd[1].toFixed(3)} I${I} J${J}`);
                    }

                    if (tool.type === 'laser') {
                        commands.push('M5');
                    }
                }
            }

            if (model.models) {
                for (const id in model.models) {
                    walk(model.models[id], offset);
                }
            }
        };

        walk(rootModel);

        commands.push('M5');
        commands.push('G0 X0 Y0');

        return commands.join('\n');
    }

    async generateRaster(imagePath: string, options: RasterOptions): Promise<string> {
        const { width, height, tool, powerMin, powerMax, invert } = options;

        const toolDiameter = tool.type === 'laser' ? tool.spotSize : (tool as any).diameter;

        const pixelWidth = Math.ceil(width / toolDiameter);
        const pixelHeight = Math.ceil(height / toolDiameter);

        const pipeline = sharp(imagePath)
            .grayscale()
            .resize(pixelWidth, pixelHeight, { fit: 'fill' });

        if (invert) {
            pipeline.negate();
        }

        const { data, info } = await pipeline.raw().toBuffer({ resolveWithObject: true });

        const lines: string[] = [];
        lines.push('; Generated by LzrCnc (Raster)');
        lines.push('G90 ; Absolute positioning');
        lines.push('M3 ; Spindle on');
        lines.push(`G0 F${options.feedrate}`);

        const stepX = width / info.width;
        const stepY = height / info.height;
        const pRange = powerMax - powerMin;

        for (let y = 0; y < info.height; y++) {
            const isEven = y % 2 === 0;
            const startX = isEven ? 0 : info.width - 1;
            const endX = isEven ? info.width : -1;
            const step = isEven ? 1 : -1;

            const yPos = (y * stepY).toFixed(3);

            for (let x = startX; x !== endX; x += step) {
                const idx = y * info.width + x;
                const intensity = data[idx];
                const power = (powerMin + (intensity / 255) * pRange).toFixed(1);
                const targetX = ((x + step) * stepX).toFixed(3);

                if (x === startX) {
                    const rx = (x * stepX).toFixed(3);
                    lines.push(`G0 X${rx} Y${yPos}`);
                }

                if (intensity > 0) {
                    lines.push(`G1 X${targetX} S${power}`);
                } else {
                    lines.push(`G1 X${targetX} S0`);
                }
            }
        }

        lines.push('M5 ; Spindle off');
        lines.push('G0 X0 Y0');

        return lines.join('\n');
    }
}
